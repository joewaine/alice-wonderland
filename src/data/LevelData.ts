/**
 * LevelData - Type definitions for level data generated by Claude API
 *
 * These interfaces define the structure of level JSON that describes
 * platforms, collectibles, NPCs, and puzzles for each chapter.
 */

export interface Vector3 {
  x: number;
  y: number;
  z: number;
}

export interface Platform {
  position: Vector3;
  size: Vector3;
  type: 'solid' | 'bouncy';
  color?: string;  // Hex color
  requires_size?: 'small' | 'normal' | 'large';
  breakable?: boolean;  // Can be destroyed by ground pound
  break_requires_size?: 'large';  // Size required to break
}

export interface AirCurrent {
  position: Vector3;
  size: Vector3;
  force: number;  // Negative = slows fall, positive = speeds up
}

export interface WaterZone {
  position: Vector3;
  size: Vector3;
  surface_y: number;  // Y position of water surface
  current?: Vector3;  // Optional water current direction/strength
}

export interface SpeedBoost {
  position: Vector3;
  size: Vector3;
  direction: Vector3;  // Direction of boost (normalized)
  force: number;       // Boost strength
}

export interface Checkpoint {
  position: Vector3;
  radius: number;
  order: number;  // 0 = start/finish, 1+ = checkpoints
}

export interface WonderStar {
  id: string;
  name: string;
  position: Vector3;
  challenge_type: 'exploration' | 'race' | 'puzzle' | 'collection' | 'skill';
  requirements: {
    // For exploration - reach a specific location
    reach_position?: Vector3;
    reach_radius?: number;
    // For race - beat a time
    beat_time?: number;
    // For puzzle - activate switches or break platforms
    break_platforms?: number;
    // For collection - collect items
    collect_stars?: number;
    collect_cards?: number;
    // For skill - perform specific moves
    perform_ground_pounds?: number;
    perform_long_jumps?: number;
  };
  hint: string;
  spawn_near?: Vector3;  // Optional spawn point when selecting this star
}

export interface Collectible {
  type: 'key' | 'star' | 'card';
  position: Vector3;
  card_suit?: 'hearts' | 'diamonds' | 'clubs' | 'spades';
  card_value?: number;
}

export interface NPC {
  name: string;
  position: Vector3;
  model_id?: string;
  dialogue: string[];
}

export interface SizePuzzle {
  area_bounds: {
    min: Vector3;
    max: Vector3;
  };
  required_size: 'small' | 'large';
  hint: string;
}

export interface Atmosphere {
  sky_color: string;      // Hex color
  fog_color: string;      // Hex color
  fog_near: number;
  fog_far: number;
  ambient_light: string;  // Hex color
}

export interface LevelData {
  chapter_number: number;
  chapter_title: string;
  setting: string;

  atmosphere: Atmosphere;

  platforms: Platform[];
  collectibles: Collectible[];
  npcs: NPC[];

  spawn_point: Vector3;
  gate_position: Vector3;

  size_puzzles: SizePuzzle[];

  // Optional chapter-specific features
  air_currents?: AirCurrent[];
  water_zones?: WaterZone[];
  speed_boosts?: SpeedBoost[];
  checkpoints?: Checkpoint[];
  wonder_stars?: WonderStar[];
}

/**
 * Validate that an object conforms to LevelData structure
 */
export function validateLevelData(data: unknown): data is LevelData {
  if (!data || typeof data !== 'object') return false;

  const level = data as LevelData;

  // Check required fields
  if (typeof level.chapter_number !== 'number') return false;
  if (typeof level.chapter_title !== 'string') return false;
  if (typeof level.setting !== 'string') return false;

  // Check arrays exist
  if (!Array.isArray(level.platforms)) return false;
  if (!Array.isArray(level.collectibles)) return false;
  if (!Array.isArray(level.npcs)) return false;
  if (!Array.isArray(level.size_puzzles)) return false;

  // Check atmosphere
  if (!level.atmosphere || typeof level.atmosphere !== 'object') return false;

  // Check spawn and gate
  if (!isVector3(level.spawn_point)) return false;
  if (!isVector3(level.gate_position)) return false;

  return true;
}

function isVector3(v: unknown): v is Vector3 {
  if (!v || typeof v !== 'object') return false;
  const vec = v as Vector3;
  return typeof vec.x === 'number' &&
         typeof vec.y === 'number' &&
         typeof vec.z === 'number';
}
