/**
 * LevelBuilder - Constructs playable levels from LevelData JSON
 *
 * Takes level data generated by Claude and creates:
 * - Platforms with physics colliders
 * - Collectibles (keys, stars, cards)
 * - NPCs with dialogue
 * - Atmosphere (fog, lighting)
 */

import * as THREE from 'three';
import RAPIER from '@dimforge/rapier3d-compat';
import type { LevelData, Platform, Collectible as CollectibleData, NPC, SizePuzzle } from '../data/LevelData';
import { assetLoader } from '../engine/AssetLoader';

export interface BuiltLevel {
  platforms: THREE.Mesh[];
  bouncyPlatforms: BouncyPlatform[];
  collectibles: CollectibleObject[];
  npcs: NPCObject[];
  sizePuzzleZones: SizePuzzleZone[];
  spawnPoint: THREE.Vector3;
  gatePosition: THREE.Vector3;
  cleanup: () => void;
}

export interface BouncyPlatform {
  mesh: THREE.Mesh;
  baseY: number;
  compressionAmount: number;
}

export interface CollectibleObject {
  mesh: THREE.Group;
  type: 'key' | 'star' | 'card';
  position: THREE.Vector3;
  collected: boolean;
  cardSuit?: string;
  cardValue?: number;
}

export interface NPCObject {
  mesh: THREE.Group;
  name: string;
  position: THREE.Vector3;
  dialogue: string[];
  dialogueIndex: number;
}

export interface SizePuzzleZone {
  bounds: THREE.Box3;
  requiredSize: 'small' | 'large';
  hint: string;
}

export class LevelBuilder {
  private scene: THREE.Scene;
  private world: RAPIER.World;
  private createdBodies: RAPIER.RigidBody[] = [];
  private createdMeshes: THREE.Object3D[] = [];

  constructor(scene: THREE.Scene, world: RAPIER.World) {
    this.scene = scene;
    this.world = world;
  }

  /**
   * Build a complete level from LevelData
   */
  async build(levelData: LevelData): Promise<BuiltLevel> {
    console.log(`Building level: ${levelData.chapter_title}`);

    // Apply atmosphere first
    this.applyAtmosphere(levelData.atmosphere);

    // Build platforms
    const { meshes: platforms, bouncy: bouncyPlatforms } = this.buildPlatforms(levelData.platforms);

    // Create collectibles
    const collectibles = this.buildCollectibles(levelData.collectibles);

    // Place NPCs (async to load models)
    const npcs = await this.buildNPCs(levelData.npcs);

    // Create size puzzle zones
    const sizePuzzleZones = this.buildSizePuzzleZones(levelData.size_puzzles);

    // Create gate
    this.buildGate(levelData.gate_position);

    // Spawn point
    const spawnPoint = new THREE.Vector3(
      levelData.spawn_point.x,
      levelData.spawn_point.y,
      levelData.spawn_point.z
    );

    const gatePosition = new THREE.Vector3(
      levelData.gate_position.x,
      levelData.gate_position.y,
      levelData.gate_position.z
    );

    return {
      platforms,
      bouncyPlatforms,
      collectibles,
      npcs,
      sizePuzzleZones,
      spawnPoint,
      gatePosition,
      cleanup: () => this.cleanup()
    };
  }

  /**
   * Apply atmosphere settings (fog, lighting, sky)
   */
  private applyAtmosphere(atmosphere: LevelData['atmosphere']): void {
    // Set background/sky color
    this.scene.background = new THREE.Color(atmosphere.sky_color);

    // Set fog
    this.scene.fog = new THREE.Fog(
      new THREE.Color(atmosphere.fog_color),
      atmosphere.fog_near,
      atmosphere.fog_far
    );

    // Find and update ambient light
    this.scene.traverse((obj) => {
      if (obj instanceof THREE.AmbientLight) {
        obj.color.set(atmosphere.ambient_light);
      }
    });
  }

  /**
   * Build platforms with physics
   */
  private buildPlatforms(platforms: Platform[]): { meshes: THREE.Mesh[], bouncy: BouncyPlatform[] } {
    const meshes: THREE.Mesh[] = [];
    const bouncy: BouncyPlatform[] = [];

    for (const platform of platforms) {
      // Visual mesh
      const geometry = new THREE.BoxGeometry(
        platform.size.x,
        platform.size.y,
        platform.size.z
      );

      const color = platform.color ? new THREE.Color(platform.color) : new THREE.Color(0x8B4513);
      const material = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.8
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(platform.position.x, platform.position.y, platform.position.z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      this.scene.add(mesh);
      this.createdMeshes.push(mesh);
      meshes.push(mesh);

      // Physics body
      const bodyDesc = RAPIER.RigidBodyDesc.fixed()
        .setTranslation(platform.position.x, platform.position.y, platform.position.z);
      const body = this.world.createRigidBody(bodyDesc);
      this.createdBodies.push(body);

      // Collider (half-extents for Rapier)
      const colliderDesc = RAPIER.ColliderDesc.cuboid(
        platform.size.x / 2,
        platform.size.y / 2,
        platform.size.z / 2
      );

      // Bouncy platforms
      if (platform.type === 'bouncy') {
        colliderDesc.setRestitution(1.5);
        // Make bouncy platforms visually distinct
        (mesh.material as THREE.MeshStandardMaterial).color.set(0xff69b4);

        // Track for animation
        bouncy.push({
          mesh,
          baseY: platform.position.y,
          compressionAmount: 0
        });
      }

      this.world.createCollider(colliderDesc, body);
    }

    console.log(`Built ${meshes.length} platforms`);
    return { meshes, bouncy };
  }

  /**
   * Build collectibles (keys, stars, cards)
   */
  private buildCollectibles(collectibles: CollectibleData[]): CollectibleObject[] {
    const objects: CollectibleObject[] = [];

    for (const collectible of collectibles) {
      const group = new THREE.Group();
      const position = new THREE.Vector3(
        collectible.position.x,
        collectible.position.y,
        collectible.position.z
      );

      // Create visual based on type
      switch (collectible.type) {
        case 'key':
          this.createKeyMesh(group);
          break;
        case 'star':
          this.createStarMesh(group);
          break;
        case 'card':
          this.createCardMesh(group, collectible.card_suit);
          break;
      }

      group.position.copy(position);
      this.scene.add(group);
      this.createdMeshes.push(group);

      objects.push({
        mesh: group,
        type: collectible.type,
        position,
        collected: false,
        cardSuit: collectible.card_suit,
        cardValue: collectible.card_value
      });
    }

    console.log(`Built ${objects.length} collectibles`);
    return objects;
  }

  /**
   * Create golden key mesh
   */
  private createKeyMesh(group: THREE.Group): void {
    const material = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      metalness: 0.8,
      roughness: 0.2,
      emissive: 0xffd700,
      emissiveIntensity: 0.3
    });

    // Key handle (torus)
    const handleGeo = new THREE.TorusGeometry(0.3, 0.08, 8, 16);
    const handle = new THREE.Mesh(handleGeo, material);
    handle.position.y = 0.3;
    group.add(handle);

    // Key shaft
    const shaftGeo = new THREE.BoxGeometry(0.1, 0.6, 0.05);
    const shaft = new THREE.Mesh(shaftGeo, material);
    shaft.position.y = -0.2;
    group.add(shaft);

    // Key teeth
    const teethGeo = new THREE.BoxGeometry(0.2, 0.1, 0.05);
    const teeth = new THREE.Mesh(teethGeo, material);
    teeth.position.set(0.05, -0.45, 0);
    group.add(teeth);

    group.userData.type = 'key';
  }

  /**
   * Create star mesh
   */
  private createStarMesh(group: THREE.Group): void {
    const material = new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffff00,
      emissiveIntensity: 0.5
    });

    // Use octahedron as simple star shape
    const geo = new THREE.OctahedronGeometry(0.4);
    const mesh = new THREE.Mesh(geo, material);
    group.add(mesh);

    // Add glow
    const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 0.3
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    group.add(glow);

    group.userData.type = 'star';
  }

  /**
   * Create playing card mesh
   */
  private createCardMesh(group: THREE.Group, suit?: string): void {
    const suitColors: Record<string, number> = {
      hearts: 0xff0000,
      diamonds: 0xff0000,
      clubs: 0x000000,
      spades: 0x000000
    };

    const color = suit ? suitColors[suit] || 0xffffff : 0xffffff;

    // Card body (white rectangle)
    const cardGeo = new THREE.BoxGeometry(0.4, 0.6, 0.02);
    const cardMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const card = new THREE.Mesh(cardGeo, cardMat);
    group.add(card);

    // Suit symbol (simple circle/diamond on front)
    const symbolGeo = new THREE.CircleGeometry(0.1, suit === 'diamonds' ? 4 : 16);
    const symbolMat = new THREE.MeshBasicMaterial({ color });
    const symbol = new THREE.Mesh(symbolGeo, symbolMat);
    symbol.position.z = 0.015;
    group.add(symbol);

    group.userData.type = 'card';
    group.userData.suit = suit;
  }

  /**
   * Build NPCs with optional GLB model loading
   */
  private async buildNPCs(npcs: NPC[]): Promise<NPCObject[]> {
    const objects: NPCObject[] = [];

    for (const npc of npcs) {
      const position = new THREE.Vector3(npc.position.x, npc.position.y, npc.position.z);
      let group: THREE.Group;

      // Try to load model if model_id is specified
      if (npc.model_id) {
        const modelPath = `${import.meta.env.BASE_URL}assets/models/${npc.model_id}.glb`;
        try {
          group = await assetLoader.loadModelWithFallback(modelPath, 0x9370db);

          // Scale down generated models (they're typically too large)
          group.scale.setScalar(0.8);

          // Center and ground the model
          const box = new THREE.Box3().setFromObject(group);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          // Move so bottom is at y=0
          group.position.y = -box.min.y;

          // Center horizontally
          group.position.x = -center.x;
          group.position.z = -center.z;

          // Wrap in container for proper positioning
          const container = new THREE.Group();
          container.add(group);
          group = container;

          console.log(`Loaded model for ${npc.name}: ${modelPath} (size: ${size.y.toFixed(1)})`);
        } catch {
          group = this.createFallbackNPC();
        }
      } else {
        group = this.createFallbackNPC();
      }

      // Name label
      this.addNameLabel(group, npc.name);

      group.position.copy(position);
      this.scene.add(group);
      this.createdMeshes.push(group);

      objects.push({
        mesh: group,
        name: npc.name,
        position,
        dialogue: npc.dialogue,
        dialogueIndex: 0
      });
    }

    console.log(`Built ${objects.length} NPCs`);
    return objects;
  }

  /**
   * Create fallback procedural NPC (capsule + head)
   */
  private createFallbackNPC(): THREE.Group {
    const group = new THREE.Group();

    // Simple capsule body
    const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x9370db });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.7;
    body.castShadow = true;
    group.add(body);

    // Head
    const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xffdab9 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.4;
    head.castShadow = true;
    group.add(head);

    return group;
  }

  /**
   * Add floating name label above NPC
   */
  private addNameLabel(group: THREE.Group, name: string): void {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d')!;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, 256, 64);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(name, 128, 40);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.position.y = 2;
    sprite.scale.set(2, 0.5, 1);
    group.add(sprite);
  }

  /**
   * Build size puzzle zones
   */
  private buildSizePuzzleZones(puzzles: SizePuzzle[]): SizePuzzleZone[] {
    const zones: SizePuzzleZone[] = [];

    for (const puzzle of puzzles) {
      const min = new THREE.Vector3(
        puzzle.area_bounds.min.x,
        puzzle.area_bounds.min.y,
        puzzle.area_bounds.min.z
      );
      const max = new THREE.Vector3(
        puzzle.area_bounds.max.x,
        puzzle.area_bounds.max.y,
        puzzle.area_bounds.max.z
      );

      // Visual indicator (wireframe box)
      const size = new THREE.Vector3().subVectors(max, min);
      const center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);

      const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
      const mat = new THREE.MeshBasicMaterial({
        color: puzzle.required_size === 'small' ? 0xff6b6b : 0x6bcfff,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(center);
      this.scene.add(mesh);
      this.createdMeshes.push(mesh);

      zones.push({
        bounds: new THREE.Box3(min, max),
        requiredSize: puzzle.required_size,
        hint: puzzle.hint
      });
    }

    console.log(`Built ${zones.length} size puzzle zones`);
    return zones;
  }

  /**
   * Build the chapter gate
   */
  private buildGate(gatePos: { x: number; y: number; z: number }): void {
    const group = new THREE.Group();

    // Two pillars
    const pillarGeo = new THREE.CylinderGeometry(0.5, 0.5, 4, 8);
    const pillarMat = new THREE.MeshStandardMaterial({
      color: 0x808080,
      metalness: 0.5,
      roughness: 0.5
    });

    const leftPillar = new THREE.Mesh(pillarGeo, pillarMat);
    leftPillar.position.set(-1.5, 2, 0);
    leftPillar.castShadow = true;
    group.add(leftPillar);

    const rightPillar = new THREE.Mesh(pillarGeo, pillarMat);
    rightPillar.position.set(1.5, 2, 0);
    rightPillar.castShadow = true;
    group.add(rightPillar);

    // Archway
    const archGeo = new THREE.TorusGeometry(1.5, 0.3, 8, 16, Math.PI);
    const arch = new THREE.Mesh(archGeo, pillarMat);
    arch.position.y = 4;
    arch.rotation.z = Math.PI;
    group.add(arch);

    // Gate barrier (red = locked)
    const barrierGeo = new THREE.PlaneGeometry(3, 4);
    const barrierMat = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const barrier = new THREE.Mesh(barrierGeo, barrierMat);
    barrier.position.y = 2;
    barrier.userData.isGateBarrier = true;
    group.add(barrier);

    group.position.set(gatePos.x, gatePos.y, gatePos.z);
    group.userData.isGate = true;
    this.scene.add(group);
    this.createdMeshes.push(group);

    console.log('Built gate at', gatePos);
  }

  /**
   * Clean up all created objects
   */
  cleanup(): void {
    // Remove physics bodies
    for (const body of this.createdBodies) {
      this.world.removeRigidBody(body);
    }
    this.createdBodies = [];

    // Remove meshes and dispose resources
    for (const mesh of this.createdMeshes) {
      this.scene.remove(mesh);
      mesh.traverse((obj) => {
        if (obj instanceof THREE.Mesh) {
          obj.geometry.dispose();
          this.disposeMaterial(obj.material);
        } else if (obj instanceof THREE.Sprite) {
          this.disposeMaterial(obj.material);
        }
      });
    }
    this.createdMeshes = [];

    // Reset fog and background
    this.scene.fog = null;
    this.scene.background = new THREE.Color(0x87ceeb);

    console.log('Level cleaned up');
  }

  /**
   * Dispose material and its textures
   */
  private disposeMaterial(material: THREE.Material | THREE.Material[]): void {
    const materials = Array.isArray(material) ? material : [material];
    for (const mat of materials) {
      // Dispose textures (check for common texture properties)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const m = mat as any;
      if (m.map?.dispose) m.map.dispose();
      if (m.normalMap?.dispose) m.normalMap.dispose();
      if (m.roughnessMap?.dispose) m.roughnessMap.dispose();
      if (m.metalnessMap?.dispose) m.metalnessMap.dispose();
      if (m.emissiveMap?.dispose) m.emissiveMap.dispose();
      mat.dispose();
    }
  }
}
